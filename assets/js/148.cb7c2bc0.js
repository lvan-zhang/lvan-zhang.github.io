(window.webpackJsonp=window.webpackJsonp||[]).push([[148],{370:function(r,e,o){"use strict";o.r(e);var c=o(0),t=Object(c.a)({},(function(){var r=this,e=r.$createElement,o=r._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[o("div",{staticClass:"custom-block tip"},[o("p",[r._v("docker虚拟化\n1.1 什么是Docker\nDocker是一个开源的应用容器引擎，它让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到安装了任何 Linux 发行版本的机器上。Docker基于LXC来实现类似VM的功能，可以在更有限的硬件资源上提供给用户更多的计算资源。与同VM等虚拟化的方式不同，LXC不属于全虚拟化、部分虚拟化或半虚拟化中的任何一个分类，而是一个操作系统级虚...")])]),r._v(" "),o("p",[r._v("@"),o("a",{attrs:{href:"%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95"}},[r._v("TOC")])]),r._v(" "),o("h2",{attrs:{id:"docker虚拟化"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#docker虚拟化"}},[r._v("#")]),r._v(" docker虚拟化")]),r._v(" "),o("h3",{attrs:{id:"_1-1-什么是docker"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-什么是docker"}},[r._v("#")]),r._v(" 1.1 什么是Docker")]),r._v(" "),o("p",[r._v("Docker是一个开源的应用容器引擎，它让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到安装了任何 Linux 发行版本的机器上。Docker基于LXC来实现类似VM的功能，可以在更有限的硬件资源上提供给用户更多的计算资源。与同VM等虚拟化的方式不同，LXC不属于全虚拟化、部分虚拟化或半虚拟化中的任何一个分类，而是一个操作系统级虚拟化。")]),r._v(" "),o("p",[r._v("Docker是直接运行在宿主操作系统之上的一个容器，使用沙箱机制完全虚拟出一个完整的操作，容器之间不会有任何接口，从而让容器与宿主机之间、容器与容器之间隔离的更加彻底。每个容器会有自己的权限管理，独立的网络与存储栈，及自己的资源管理能，使同一台宿主机上可以友好的共存多个容器。")]),r._v(" "),o("p",[r._v("Docker借助Linux的内核特性，如：控制组（Control Group）、命名空间（Namespace）等，并直接调用操作系统的系统调用接口。从而降低每个容器的系统开销，并实现降低容器复杂度、启动快、资源占用小等特征。")]),r._v(" "),o("h3",{attrs:{id:"_1-2-docker的构成"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-docker的构成"}},[r._v("#")]),r._v(" 1.2 Docker的构成")]),r._v(" "),o("h4",{attrs:{id:"_1-2-1-docker架构"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-1-docker架构"}},[r._v("#")]),r._v(" 1.2.1 Docker架构")]),r._v(" "),o("p",[r._v("Docker使用客户端-服务器 (C/S) 架构模式 使用远程API来管理和创建Docker容器。Docker 容器（Container）通过 Docker 镜像（Image）来创建，二者之间的关系类似于面向对象编程中的对象与类。")]),r._v(" "),o("p",[r._v("其中，Docker客户端用于向Docker服务器或守护进程发送请求。而服务器或守护进程会接受来自客户的请求（创建、运行、分发容器），并在处理完请求后返回响应结果。Docker提供了一个命令行工具docker，及一整套RESTful API。客户端和服务端既可以运行在一个机器上，也可通过 socket或者RESTful API来进行通信。\n"),o("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191104161605327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk3MjQzNw==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),r._v(" "),o("h4",{attrs:{id:"_1-2-1-docker核心组件"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-1-docker核心组件"}},[r._v("#")]),r._v(" 1.2.1 Docker核心组件")]),r._v(" "),o("p",[r._v("Docker Image（镜像）、Registry（仓库）、Docker Container（容器）是Docker中包含几个核心组件（核心概念），这几个组件介绍如下：")]),r._v(" "),o("ul",[o("li",[r._v("Docker Image - 镜像")])]),r._v(" "),o("p",[r._v("镜像用于构建Docker容器，是构成Docker的基础。它类似于虚拟机中的镜像，但它非常小，可以将它理解为容器的源代码。是一种层式结构的增量文件系统，由一系列命令一步步组成。")]),r._v(" "),o("p",[r._v("与传统虚拟机中的镜像相比，Docker镜像是分层的，也更为轻量。你可以对其进行快速跌代，通过版本管理及增量的文件系统，Docker提供了一套十分简单的机制来创建和更新现有的镜像，用户甚至可以从网上下载一个已经现有的应用镜像，再通过简单的命令就可以直接使用。")]),r._v(" "),o("ul",[o("li",[r._v("Registry - 仓库")])]),r._v(" "),o("p",[r._v("Registry是Docker用于存放镜像文件仓库，仓库分为开放（Public）和私有（Private），其设计理念非常类似于代码仓库Git。")]),r._v(" "),o("p",[r._v("Docker Hub是Docker公司运营的Registry，也是最大的Docker仓库，用户可以在上面注册帐号分享并保存自己的镜像。除Docker Hub外，还有很多第三方镜像仓库。如果不希望自己的镜像被其它人看到，你甚至可以架设自己的私有仓库，以增强安全性或满足一些特殊需求。")]),r._v(" "),o("p",[r._v("注意：也可以将Repository认为是Docker仓库，实际上二者区分并不严格。")]),r._v(" "),o("ul",[o("li",[r._v("Docker Container - 容器")])]),r._v(" "),o("p",[r._v("容器是用于运行镜像的沙箱环境，它是从镜像创建的应用运行实例，可以将其启动、开始、停止、删除。而这些容器都是相互隔离、互不可见的。我们可以理解为：镜像是Docker生命周期的打包和构建阶段，而容器Docker的启动和执行阶段。")]),r._v(" "),o("p",[r._v("Docker借签了集装箱的设计概念，不同的是集装箱运送的货物，而Docker运送的是软件。和集装箱一样，我们并不需要关心里面装的是什么，只需要将应用按标准的形式装进去，然后上传到Registry，在需要使用它的服务器下载部署即可。Docker容器可以非常方便的替换，且各个容器都有良好的通用性，易于分发和叠加。")]),r._v(" "),o("h3",{attrs:{id:"_1-3-docker的适用范围"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-docker的适用范围"}},[r._v("#")]),r._v(" 1.3 Docker的适用范围")]),r._v(" "),o("p",[r._v("正如前所述，Docker为容器提供了标准的隔离性，而各个容器本身就是一个标准的系统环境。因些，Docker非常适合构建服务块，以下是Docker的一些应用场景：")]),r._v(" "),o("ul",[o("li",[r._v("方便应用的自动化打包与部署 - 加速本地开发和构建流程，使其更加高效和轻量化。本地开发人员可以构建、运行并分享Docker容器。容器可以在开发环境中构建，然后轻松的提交到测试环境，并最终进入生产环境。")]),r._v(" "),o("li",[r._v("创建轻量、私密的PAAS环境")]),r._v(" "),o("li",[r._v("部署和扩展Web应用、数据库与后台服务 - 可以让独立服务在不同环境中得到相同的执行结果")]),r._v(" "),o("li",[r._v("连续的集成/部署、测试自动化 - 开发者可以在本地构建运行或测试环境，而不是直接在生产环境中部署、测试。")])]),r._v(" "),o("p",[r._v("Docker也并不是万能的，其设计目的也并不是要成为KVM等的替代品。不可避免的，Docker也会有一些局限性，如：")]),r._v(" "),o("ul",[o("li",[r._v("基于Linux内核，所以只能运行于Linux环境中，且只能64位主机上")]),r._v(" "),o("li",[r._v("基于LXC实现的容器，而LXC是基于Linux内核中的cgroup。因此，Docker容器使用的权限、物理资源等也受限于LXC")])]),r._v(" "),o("h2",{attrs:{id:"docker作用"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#docker作用"}},[r._v("#")]),r._v(" docker作用")]),r._v(" "),o("p",[o("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191002005315303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk3MjQzNw==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),r._v(" "),o("h2",{attrs:{id:"docker与虚拟机的区别"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#docker与虚拟机的区别"}},[r._v("#")]),r._v(" docker与虚拟机的区别")]),r._v(" "),o("p",[r._v("我们用的虚拟机如VMware，输入软件虚拟化的完全虚拟化，而docker属于操作系统虚拟化。虚拟机启动需要数分钟，而Docker容器可以在数毫秒内启动。由于没有臃肿的从操作系统，Docker可以节省大量的磁盘空间以及其他系统资源。")]),r._v(" "),o("p",[r._v("虚拟机更擅长于彻底隔离整个运行环境，而Docker通常用于隔离不同的应用，例如前端，后端以及数据库。")])])}),[],!1,null,null,null);e.default=t.exports}}]);